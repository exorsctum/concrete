mod lc3 {
    extern fn malloc(size: u64) -> *mut u8;
    extern fn fopen(name: *mut u8, mode: *mut u8) -> *mut u8;
    extern fn fclose(file: *mut u8) -> i32;
    extern fn fread(ptr: *mut u8, size: u64, nitems: u64, stream: *mut u8) -> u64;
    extern fn fwrite(ptr: *const u8, size: u64, nitems: u64, stream: *mut u8) -> u64;
    extern fn exit(status: i32);

    struct Memory {
        data: *mut u16,
    }

    impl Memory {
        pub fn new() -> Memory {
            let data: *mut u16 = malloc(65536 * 2) as *mut u16;
            let memory: Memory = Memory { data: data };
            return memory;
        }

        pub fn at(&self, addr: u16) -> *mut u16 {
            let target_ptr: *mut u16 = self.data + addr;
            return target_ptr;
        }

        pub fn get(&self, addr: u16) -> u16 {
            let target_ptr: *mut u16 = self.data + addr;
            return *target_ptr;
        }

        pub fn set(&mut self, addr: u16, value: u16) {
            let target_ptr: *mut u16 = self.data + addr;
            *target_ptr = value;
        }
    }

    #[langitem = "String"]
    pub struct String {
        ptr: *mut u8,
        len: u64,
        cap: u64,
    }

    fn lsl(_x: u16, _n: u16) -> u16 {
        let mut x: u16 = _x;
        let mut n: u16 = _n;
        while n > 0 {
            x = x * 2;
            n = n - 1;
        }
        return x;
    }
    fn lsr(_x: u16, _n: u16) -> u16 {
        let mut x: u16 = _x;
        let mut n: u16 = _n;
        while n > 0 {
            x = x / 2;
            n = n - 1;
        }
        return x;
    }

    fn swap16(x: u16) -> u16 {
        // return ( x << 8 ) | ( x >> 8 )
        return lsl(x, 8) + lsr(x, 8);
    }

    enum Register {
        R0 = 0,
        R1,
        R2,
        R3,
        R4,
        R5,
        R6,
        R7,
        ProgramCounter,
        ConditionFlags,
    }

    impl Register {
        pub fn discriminant(self) -> u64 {
            match self {
                Register#R0 => {
                    return 0;
                },
                Register#R1 => {
                    return 1;
                },
                Register#R2 => {
                    return 2;
                },
                Register#R3 => {
                    return 3;
                },
                Register#R4 => {
                    return 4;
                },
                Register#R5 => {
                    return 5;
                },
                Register#R6 => {
                    return 6;
                },
                Register#R7 => {
                    return 7;
                },
                Register#ProgramCounter => {
                    return 8;
                },
                Register#ConditionFlags => {
                    return 9;
                },
            }
        }
    }

    enum OpCodes {
        Branch = 0,
        Add,
        Load,
        Store,
        JumpRegister,
        BitwiseAnd,
        LoadRegister,
        StoreRegister,
        Unused,
        BitwiseNot,
        LoadIndirect,
        StoreIndirect,
        Jump,
        Reserved,
        LoadEffectiveAddress,
        ExecuteTrap,
    }

    enum ConditionFlags {
        Positive = 0,
        Zero = 2,
        Negative = 4,
    }

    pub fn main() -> u16 {
        let mut memory: Memory = Memory#new();

        let image_path: String = "asm/hello_world.obj";
        let mode: String = "rb";
        let file: *mut u8 = fopen(image_path.ptr, mode.ptr);
        if (file as u64) == 0 {
            exit(1);
        }

        let mut origin: u16 = 0;
        fread(&origin as *mut u8, 2, 1, file);
        origin = swap16(origin);

        let max_read: u64 = 65536 - (origin as u64);
        let origin_ptr: *mut u16 = memory.at(origin);
        let read: u64 = fread(origin_ptr as *mut u8, 2, max_read, file);
        fclose(file);

        truncate("memory");
        dump("memory", memory.at(0) as *const u8, (origin as u64) * 2 + read * 2);

        let mut current_ptr: *mut u16 = origin_ptr;
        let mut remaining_to_swap: u64 = read;
        while (remaining_to_swap > 0) {
            *current_ptr = swap16(*current_ptr);
            current_ptr = current_ptr + 1;
            remaining_to_swap = remaining_to_swap - 1;
        }

        truncate("swapped");
        dump("swapped", memory.at(0) as *const u8, (origin as u64) * 2 + read * 2);

        let registers: [u16; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

        return 0;
    }

    pub fn dump(path: String, ptr: *const u8, size: u64) {
        let mode: String = "ab";
        let file: *mut u8 = fopen(path.ptr, mode.ptr);
        if (file as u64) == 0 {
            exit(1);
        }
        fwrite(ptr, size, 1, file);
        fclose(file);
    }

    pub fn truncate(path: String) {
        let mode: String = "wb";
        let file: *mut u8 = fopen(path.ptr, mode.ptr);
        if (file as u64) == 0 {
            exit(1);
        }
        fclose(file);
    }
}
