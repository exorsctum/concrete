mod lc3 {
    import std.libc.{malloc, free, fopen, fclose, fread, fwrite, puts, putchar, exit};
    import builtins.{lsl, lsr, asr, and};

    struct Memory {
        data: *mut u16,
    }

    impl Memory {
        pub fn new() -> Memory {
            let data: *mut u16 = malloc(65536 * 2) as *mut u16;
            let memory: Memory = Memory { data: data };
            return memory;
        }

        pub fn at(&self, addr: u16) -> *mut u16 {
            let target_ptr: *mut u16 = self.data + addr;
            return target_ptr;
        }

        pub fn get(&self, addr: u16) -> u16 {
            let target_ptr: *mut u16 = self.data + addr;
            return *target_ptr;
        }

        pub fn set(&mut self, addr: u16, value: u16) {
            let target_ptr: *mut u16 = self.data + addr;
            *target_ptr = value;
        }
    }

    fn swap16(x: u16) -> u16 {
        // return ( x << 8 ) | ( x >> 8 )
        return lsl(x, 8) + lsr(x, 8);
    }

    enum Register {
        R0 = 0,
        R1,
        R2,
        R3,
        R4,
        R5,
        R6,
        R7,
        ProgramCounter,
        ConditionFlags,
    }

    impl Register {
        pub fn discriminant(self) -> u64 {
            match self {
                Register#R0 => {
                    return 0;
                },
                Register#R1 => {
                    return 1;
                },
                Register#R2 => {
                    return 2;
                },
                Register#R3 => {
                    return 3;
                },
                Register#R4 => {
                    return 4;
                },
                Register#R5 => {
                    return 5;
                },
                Register#R6 => {
                    return 6;
                },
                Register#R7 => {
                    return 7;
                },
                Register#ProgramCounter => {
                    return 8;
                },
                Register#ConditionFlags => {
                    return 9;
                },
            }
        }
    }

    enum OpCodes {
        Branch = 0,
        Add,
        Load,
        Store,
        JumpRegister,
        BitwiseAnd,
        LoadRegister,
        StoreRegister,
        Unused,
        BitwiseNot,
        LoadIndirect,
        StoreIndirect,
        Jump,
        Reserved,
        LoadEffectiveAddress,
        ExecuteTrap,
    }

    impl OpCodes {
        pub fn discriminant(self) -> u64 {
            match self {
                OpCodes#Branch => {
                    return 0;
                },
                OpCodes#Add => {
                    return 1;
                },
                OpCodes#Load => {
                    return 2;
                },
                OpCodes#Store => {
                    return 3;
                },
                OpCodes#JumpRegister => {
                    return 4;
                },
                OpCodes#BitwiseAnd => {
                    return 5;
                },
                OpCodes#LoadRegister => {
                    return 6;
                },
                OpCodes#StoreRegister => {
                    return 7;
                },
                OpCodes#Unused => {
                    return 8;
                },
                OpCodes#BitwiseNot => {
                    return 9;
                },
                OpCodes#LoadIndirect => {
                    return 10;
                },
                OpCodes#StoreIndirect => {
                    return 11;
                },
                OpCodes#Jump => {
                    return 12;
                },
                OpCodes#Reserved => {
                    return 13;
                },
                OpCodes#LoadEffectiveAddress => {
                    return 14;
                },
                OpCodes#ExecuteTrap => {
                    return 15;
                },
            }
        }
    }

    fn opcode_from_discriminant(x: u16) -> OpCodes {
        if x == 0 {
            let opcode: OpCodes = OpCodes#Branch;
            return opcode;
        }
        if x == 1 {
            let opcode: OpCodes = OpCodes#Add;
            return opcode;
        }
        if x == 2 {
            let opcode: OpCodes = OpCodes#Load;
            return opcode;
        }
        if x == 3 {
            let opcode: OpCodes = OpCodes#Store;
            return opcode;
        }
        if x == 4 {
            let opcode: OpCodes = OpCodes#JumpRegister;
            return opcode;
        }
        if x == 5 {
            let opcode: OpCodes = OpCodes#BitwiseAnd;
            return opcode;
        }
        if x == 6 {
            let opcode: OpCodes = OpCodes#LoadRegister;
            return opcode;
        }
        if x == 7 {
            let opcode: OpCodes = OpCodes#StoreRegister;
            return opcode;
        }
        if x == 8 {
            let opcode: OpCodes = OpCodes#Unused;
            return opcode;
        }
        if x == 9 {
            let opcode: OpCodes = OpCodes#BitwiseNot;
            return opcode;
        }
        if x == 10 {
            let opcode: OpCodes = OpCodes#LoadIndirect;
            return opcode;
        }
        if x == 11 {
            let opcode: OpCodes = OpCodes#StoreIndirect;
            return opcode;
        }
        if x == 12 {
            let opcode: OpCodes = OpCodes#Jump;
            return opcode;
        }
        if x == 13 {
            let opcode: OpCodes = OpCodes#Reserved;
            return opcode;
        }
        if x == 14 {
            let opcode: OpCodes = OpCodes#LoadEffectiveAddress;
            return opcode;
        }
        if x == 15 {
            let opcode: OpCodes = OpCodes#ExecuteTrap;
            return opcode;
        }
        exit(1);
    }

    enum ConditionFlags {
        Positive = 0,
        Zero = 2,
        Negative = 4,
    }

    pub fn main() -> u16 {
        let mut memory: Memory = Memory#new();

        let image_path: String = "asm/hello_world.obj";
        let mode: String = "rb";
        let file: *mut u8 = fopen(image_path.ptr as *const u8, mode.ptr as *const u8);
        if (file as u64) == 0 {
            exit(1);
        }

        let mut origin: u16 = 0;
        fread(&origin as *mut u8, 2, 1, file);
        origin = swap16(origin);

        let max_read: u64 = 65536 - (origin as u64);
        let origin_ptr: *mut u16 = memory.at(origin);
        let read: u64 = fread(origin_ptr as *mut u8, 2, max_read, file);
        fclose(file);

        truncate("image");
        dump(
            "image",
            memory.at(0) as *const u8,
            (origin as u64) * 2 + read * 2,
        );

        let mut current_ptr: *mut u16 = origin_ptr;
        let mut remaining_to_swap: u64 = read;
        while (remaining_to_swap > 0) {
            *current_ptr = swap16(*current_ptr);
            current_ptr = current_ptr + 1;
            remaining_to_swap = remaining_to_swap - 1;
        }

        truncate("memory");
        dump(
            "memory",
            memory.at(0) as *const u8,
            (origin as u64) * 2 + read * 2,
        );

        let mut registers: [u16; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

        let pc: Register = Register#ProgramCounter;
        let cond: Register = Register#ConditionFlags;
        let r7: Register = Register#R7;
        let r0: Register = Register#R0;
        registers[pc.discriminant()] = 12288;

        truncate("instructions");
        let mut running: bool = true;
        while running {
            let instruction: u16 = memory.get(registers[pc.discriminant()]);
            let opcode_value: u16 = lsr(instruction, 12);

            registers[pc.discriminant()] = registers[pc.discriminant()] + 1;

            dump("instructions", &instruction as *const u8, 2);

            let opcode: OpCodes = opcode_from_discriminant(opcode_value);

            match opcode {
                OpCodes#Branch => {
                    return 0;
                },
                OpCodes#Add => {
                    return 1;
                },
                OpCodes#Load => {
                    return 2;
                },
                OpCodes#Store => {
                    return 3;
                },
                OpCodes#JumpRegister => {
                    return 4;
                },
                OpCodes#BitwiseAnd => {
                    return 5;
                },
                OpCodes#LoadRegister => {
                    return 6;
                },
                OpCodes#StoreRegister => {
                    return 7;
                },
                OpCodes#Unused => {
                    return 8;
                },
                OpCodes#BitwiseNot => {
                    return 9;
                },
                OpCodes#LoadIndirect => {
                    return 10;
                },
                OpCodes#StoreIndirect => {
                    return 11;
                },
                OpCodes#Jump => {
                    return 12;
                },
                OpCodes#Reserved => {
                    return 13;
                },
                OpCodes#LoadEffectiveAddress => {
                    let register: u16 = and(lsr(instruction, 9), 7);
                    let pc_offset: u16 = asr(lsl(instruction, 7) as i16, 7) as u16;
                    registers[register] = registers[pc.discriminant()] + pc_offset;

                    if registers[register] == 0 {
                        registers[cond.discriminant()] = 0;
                    } else {
                        // cannot inline variable
                        let last_bit: u16 = lsr(registers[register], 15);
                        if last_bit == 1 {
                            registers[cond.discriminant()] = 2;
                        } else {
                            registers[cond.discriminant()] = 4;
                        }
                    }
                },
                OpCodes#ExecuteTrap => {
                    registers[r7.discriminant()] = registers[pc.discriminant()];
                    let trap_instruction: u16 = and(instruction, 255);

                    if trap_instruction == 34 {
                        let start: u16 = registers[r0.discriminant()];

                        let mut p_c: *mut u16 = memory.at(start);
                        let mut c: u8  = *p_c as u8;


                        // c != 0 does not work!! why?
                        while c > 0 {
                            putchar(c as u8);
                            p_c = p_c + 1;
                            c = *p_c as u8;
                        }

                        
                    } else {
                        if trap_instruction == 37 {
                            print("HALT");
                            running = false;
                        }
                    }
                }
            }
        }

        truncate("final");
        dump("final", memory.at(0) as *const u8, 65536 * 2);

        return 0;
    }

    pub fn dump(path: String, ptr: *const u8, size: u64) {
        let mode: String = "ab";
        let file: *mut u8 = fopen(path.ptr as *const u8, mode.ptr as *const u8);
        if (file as u64) == 0 {
            exit(1);
        }
        fwrite(ptr, size, 1, file);
        fclose(file);
    }

    pub fn truncate(path: String) {
        let mode: String = "wb";
        let file: *mut u8 = fopen(path.ptr as *const u8, mode.ptr as *const u8);
        if (file as u64) == 0 {
            exit(1);
        }
        fclose(file);
    }

    pub fn print(value: String) {
        if value.len > 0 {
            puts(value.ptr as *const u8);
        }
    }
}

mod builtins {
    fn lsl(x: u16, n: u16) -> u16 {
        let mut x_mut: u16 = x;
        let mut n_mut: u16 = n;
        while n_mut > 0 {
            x_mut = x_mut * 2;
            n_mut = n_mut - 1;
        }
        return x_mut;
    }
    fn lsr(x: u16, n: u16) -> u16 {
        let mut x_mut: u16 = x;
        let mut n_mut: u16 = n;
        while n_mut > 0 {
            x_mut = x_mut / 2;
            n_mut = n_mut - 1;
        }
        return x_mut;
    }
    fn asr(x: i16, n: u16) -> i16 {
        let mut x_mut: i16 = x;
        let mut n_mut: u16 = n;
        while n_mut > 0 {
            x_mut = x_mut / 2;
            n_mut = n_mut - 1;
        }
        return x_mut;
    }
    fn and(x: u16, y: u16) -> u16 {
        let mut i: u16 = 0;
        let mut z: u16 = 0;
        while i < 16 {
            let xi: u16 = lsr(lsl(x, 15 - i), 15);
            let yi: u16 = lsr(lsl(y, 15 - i), 15);
            // cannot use and gates in conditional
            if xi > 0 {
                if yi > 0 {
                    z = z + lsl(1, i);
                }
            }
            i = i + 1;
        }
        return z;
    }
}
