mod lc3 {
    import std.libc.{malloc, free, fopen, fclose, fread, fwrite, puts, putchar, exit};
    import builtins.{lsl, lsr, asr, and};
    import std.io.{print};
    import debug.{debug_string, dump_memory, truncate_file};

    struct Memory {
        data: *mut u16,
    }

    impl Memory {
        pub fn new() -> Memory {
            let data: *mut u16 = malloc(65536 * 2) as *mut u16;
            let memory: Memory = Memory { data: data };
            return memory;
        }

        pub fn at(&self, addr: u16) -> *mut u16 {
            let target_ptr: *mut u16 = self.data + addr;
            return target_ptr;
        }

        pub fn get(&self, addr: u16) -> u16 {
            let target_ptr: *mut u16 = self.data + addr;
            return *target_ptr;
        }

        pub fn set(&mut self, addr: u16, value: u16) {
            let target_ptr: *mut u16 = self.data + addr;
            *target_ptr = value;
        }
    }

    fn swap16(x: u16) -> u16 {
        // return ( x << 8 ) | ( x >> 8 )
        return lsl(x, 8) + lsr(x, 8);
    }

    const MEMORY_SIZE: u64 = 65536;
    const REGISTER_SIZE: u64 = 10;

    // FIX: It would be great to use an Enum here
    const REGISTER_R0: u64 = 0;
    const REGISTER_R1: u64 = 1;
    const REGISTER_R2: u64 = 2;
    const REGISTER_R3: u64 = 3;
    const REGISTER_R4: u64 = 4;
    const REGISTER_R5: u64 = 5;
    const REGISTER_R6: u64 = 6;
    const REGISTER_R7: u64 = 7;
    const REGISTER_PC: u64 = 8;
    const REGISTER_COND: u64 = 9;

    // FIX: It would be great to use an Enum here
    const OPCODE_BR: u16 = 0;
    const OPCODE_ADD: u16 = 1;
    const OPCODE_LD: u16 = 2;
    const OPCODE_ST: u16 = 3;
    const OPCODE_JSR: u16 = 4;
    const OPCODE_AND: u16 = 5;
    const OPCODE_LDR: u16 = 6;
    const OPCODE_STR: u16 = 7;
    const OPCODE_RTI: u16 = 8;
    const OPCODE_NOT: u16 = 9;
    const OPCODE_LDI: u16 = 10;
    const OPCODE_STI: u16 = 11;
    const OPCODE_JMP: u16 = 12;
    const OPCODE_RES: u16 = 13;
    const OPCODE_LEA: u16 = 14;
    const OPCODE_TRA: u16 = 15;

    // FIX: It would be great to use an Enum here
    const CONDITION_FLAG_POS: u16 = 0;
    const CONDITION_FLAG_ZERO: u16 = 2;
    const CONDITION_FLAG_NEG: u16 = 4;

    const INITIAL_PC: u16 = 12288;

    pub fn main() -> u16 {
        let mut memory: Memory = Memory#new();

        let image_path: String = "asm/hello_world.obj";
        let mode: String = "rb";
        let file: *mut u8 = fopen(image_path.ptr as *const u8, mode.ptr as *const u8);
        if (file as u64) == 0 {
            exit(1);
        }

        let mut origin: u16 = 0;
        fread(&origin as *mut u8, 2, 1, file);
        origin = swap16(origin);

        let max_read: u64 = 65536 - (origin as u64);
        let origin_ptr: *mut u16 = memory.at(origin);
        let read: u64 = fread(origin_ptr as *mut u8, 2, max_read, file);
        fclose(file);

        let mut current_ptr: *mut u16 = origin_ptr;
        let mut remaining_to_swap: u64 = read;
        while (remaining_to_swap > 0) {
            *current_ptr = swap16(*current_ptr);
            current_ptr = current_ptr + 1;
            remaining_to_swap = remaining_to_swap - 1;
        }

        truncate_file("image");
        dump_memory::<u16>("image", origin_ptr as *const u16, read);

        // FIX: Cannot use `REGISTER_SIZE` constant here
        let mut registers: [u16; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

        // Initialize PC
        registers[REGISTER_PC] = INITIAL_PC;

        truncate_file("instructions");
        truncate_file("registers");

        let mut running: bool = true;
        while running {
            let instruction: u16 = memory.get(registers[REGISTER_PC]);
            let opcode: u16 = lsr(instruction, 12);

            dump_memory::<u16>("instructions", &instruction as *const u16, 1);
            dump_memory::<u16>("registers", &registers as *const u16, 10);

            // Increase PC before execution - this is a requirement.
            registers[REGISTER_PC] = registers[REGISTER_PC] + 1;

            // FIX: Cannot use match here (or if else)
            // FIX: Cannot use const in binary expression

            let opcode_br: u16 = OPCODE_BR as u16;
            if opcode == opcode_br {
                return opcode;
            };
            let opcode_add: u16 = OPCODE_ADD as u16;
            if opcode == opcode_add {
                return opcode;
            };
            let opcode_ld: u16 = OPCODE_LD as u16;
            if opcode == opcode_ld {
                return opcode;
            };
            let opcode_st: u16 = OPCODE_ST as u16;
            if opcode == opcode_st {
                return opcode;
            };
            let opcode_jsr: u16 = OPCODE_JSR as u16;
            if opcode == opcode_jsr {
                return opcode;
            };
            let opcode_and: u16 = OPCODE_AND as u16;
            if opcode == opcode_and {
                return opcode;
            };
            let opcode_ldr: u16 = OPCODE_LDR as u16;
            if opcode == opcode_ldr {
                return opcode;
            };
            let opcode_str: u16 = OPCODE_STR as u16;
            if opcode == opcode_str {
                return opcode;
            };
            let opcode_rti: u16 = OPCODE_RTI as u16;
            if opcode == opcode_rti {
                return opcode;
            };
            let opcode_not: u16 = OPCODE_NOT as u16;
            if opcode == opcode_not {
                return opcode;
            };
            let opcode_ldi: u16 = OPCODE_LDI as u16;
            if opcode == opcode_ldi {
                return opcode;
            };
            let opcode_sti: u16 = OPCODE_STI as u16;
            if opcode == opcode_sti {
                return opcode;
            };
            let opcode_jmp: u16 = OPCODE_JMP as u16;
            if opcode == opcode_jmp {
                return opcode;
            };
            let opcode_res: u16 = OPCODE_RES as u16;
            if opcode == opcode_res {
                return opcode;
            };
            let opcode_lea: u16 = OPCODE_LEA as u16;
            if opcode == opcode_lea {
                let register: u16 = and(lsr(instruction, 9), 7);
                let pc_offset: u16 = asr(lsl(instruction, 7) as i16, 7) as u16;
                registers[register] = registers[REGISTER_PC] + pc_offset;

                if registers[register] == 0 {
                    registers[REGISTER_COND] = 0;
                } else {
                    // cannot inline variable
                    let last_bit: u16 = lsr(registers[register], 15);
                    if last_bit == 1 {
                        registers[REGISTER_COND] = 2;
                    } else {
                        registers[REGISTER_COND] = 4;
                    }
                }
            };
            let opcode_tra: u16 = OPCODE_TRA as u16;
            if opcode == opcode_tra {
                registers[REGISTER_R7] = registers[REGISTER_PC];
                let trap_instruction: u16 = and(instruction, 255);

                if trap_instruction == 34 {
                    let start: u16 = registers[REGISTER_R0];

                    let mut p_c: *mut u16 = memory.at(start);
                    let mut c: u8  = *p_c as u8;


                    // c != 0 does not work!! why?
                    while c > 0 {
                        putchar(c as u8);
                        p_c = p_c + 1;
                        c = *p_c as u8;
                    }

                    
                } else {
                    if trap_instruction == 37 {
                        let msg: String = "HALT";
                        print(&msg);
                        running = false;
                    }
                }
            }
        }

        return 0;
    }
}

mod builtins {
    fn lsl(x: u16, n: u16) -> u16 {
        let mut x_mut: u16 = x;
        let mut n_mut: u16 = n;
        while n_mut > 0 {
            x_mut = x_mut * 2;
            n_mut = n_mut - 1;
        }
        return x_mut;
    }
    fn lsr(x: u16, n: u16) -> u16 {
        let mut x_mut: u16 = x;
        let mut n_mut: u16 = n;
        while n_mut > 0 {
            x_mut = x_mut / 2;
            n_mut = n_mut - 1;
        }
        return x_mut;
    }
    fn asr(x: i16, n: u16) -> i16 {
        let mut x_mut: i16 = x;
        let mut n_mut: u16 = n;
        while n_mut > 0 {
            x_mut = x_mut / 2;
            n_mut = n_mut - 1;
        }
        return x_mut;
    }
    fn and(x: u16, y: u16) -> u16 {
        let mut i: u16 = 0;
        let mut z: u16 = 0;
        while i < 16 {
            // keep bit at index i
            let xi: u16 = lsr(lsl(x, 15 - i), 15);
            let yi: u16 = lsr(lsl(y, 15 - i), 15);
            // cannot use and gates in conditional
            if xi > 0 {
                if yi > 0 {
                    // set bit at index i on z
                    z = z + lsl(1, i);
                }
            }
            i = i + 1;
        }
        return z;
    }
}

mod debug {
    import std.libc.{puts, fopen, fclose, fwrite, exit};
    import std.string.{String};
    import std.mem.{sizeof};

    pub fn debug_string(value: String) {
        puts(value.ptr as *const u8);
    }

    pub fn truncate_file(path: String) {
        let mode: String = "wb";
        let file: *mut u8 = fopen(path.ptr as *const u8, mode.ptr as *const u8);
        if (file as u64) == 0 {
            exit(1);
        }
        fclose(file);
    }

    pub fn dump_memory<T>(path: String, ptr: *const T, length: u64) {
        let mode: String = "ab";
        let file: *mut u8 = fopen(path.ptr as *const u8, mode.ptr as *const u8);
        if (file as u64) == 0 {
            exit(1);
        }
        fwrite(ptr as *const u8, sizeof::<T>(), length, file);
        fclose(file);
    }
}
